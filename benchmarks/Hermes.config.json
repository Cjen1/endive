{
    "preds"  :  [
        "nodeState[VARI] = \"valid\"",
        "nodeState[VARI] = \"invalid\"",
        "nodeState[VARI] = \"invalid_write\"",
        "nodeState[VARI] = \"write\"",
        "nodeState[VARI] = \"replay\"",
        "nodeState[VARK] = \"valid\"",
        "nodeState[VARK] = \"invalid\"",
        "nodeState[VARK] = \"invalid_write\"",
        "nodeState[VARK] = \"write\"",
        "nodeState[VARK] = \"replay\"",
        "nodeState[VARJ] = \"valid\"",
        "nodeState[VARJ] = \"invalid\"",
        "nodeState[VARJ] = \"invalid_write\"",
        "nodeState[VARJ] = \"write\"",
        "nodeState[VARJ] = \"replay\"",
        "nodeTS[VARI] = nodeTS[VARJ]",
        "nodeTS[VARI].version = nodeTS[VARJ].version",
        "nodeTS[VARI].version = nodeTS[VARK].version",
        "nodeTS[VARI].version > nodeTS[VARJ].version",
        "nodeTS[VARI].version >= nodeTS[VARJ].version",
        "nodeTS[VARI].version < nodeTS[VARJ].version",
        "nodeTS[VARI].tieBreaker = nodeTS[VARJ].tieBreaker",
        "nodeTS[VARI].tieBreaker = nodeTS[VARK].tieBreaker",
        "nodeTS[VARI].tieBreaker < nodeTS[VARJ].tieBreaker",
        "nodeTS[VARI].tieBreaker < nodeTS[VARK].tieBreaker",
        "nodeTS[VARI].tieBreaker > nodeTS[VARJ].tieBreaker",
        "nodeTS[VARI].tieBreaker <= nodeTS[VARJ].tieBreaker",
        "VARI \\in aliveNodes",
        "VARJ \\in aliveNodes",
        "VARK \\in aliveNodes",
        "(VARMI.type = \"VAL\")",
        "(VARMI.type = \"VAL\") => VARMI.version = nodeTS[VARI].version",
        "(VARMI.type = \"VAL\") => VARMI.version < nodeTS[VARI].version",
        "(VARMI.type = \"VAL\") => VARMI.version = nodeTS[VARK].version",
        "(VARMI.type = \"VAL\") => VARMI.tieBreaker = nodeTS[VARI].tieBreaker",
        "(VARMI.type = \"VAL\") => VARMI.tieBreaker = nodeTS[VARK].tieBreaker",
        "(VARMI.type = \"VAL\") => VARMI.tieBreaker < nodeTS[VARI].tieBreaker",
        "(VARMI.type = \"VAL\") => VARMI.tieBreaker < nodeTS[VARK].tieBreaker",
        "(VARMI.type = \"VAL\") => equalTS(VARMI.version, VARMI.tieBreaker, nodeTS[VARI].version, nodeTS[VARI].tieBreaker)",
        "(VARMI.type = \"VAL\") => equalTS(VARMI.version, VARMI.tieBreaker, nodeTS[VARK].version, nodeTS[VARK].tieBreaker)"
    ],
    "preds_alt" : [],
    "safety"  :  "HConsistent",
    "constants"  : {
        "H_NODES" : [ "{33,44,55}"],
        "H_MAX_VERSION" : ["2"]
    },
    "actions": [],
    "constraint"  :  "",
    "quant_inv"  :  "\\A VARI \\in H_NODES : \\A VARJ \\in H_NODES : \\E VARK \\in H_NODES : \\A VARMI \\in msgs : ",
    "quant_inv_alt"  :  null,
    "quant_vars": ["VARI", "VARJ", "VARK", "VARMI"],
    "model_consts"  :  "",
    "symmetry" : false,
    "typeok"  :  "TypeOKRandom",
    "tlc_specific_spec": true,
    "try_final_minimize": false,
    "max_tlc_inv_depth": 17,
    "simulate"  :  true,
    "local_grammars": {},
    "tlaps_proof_config": {
        "assumes": [
            "IsFiniteSet(Server)",
            "Nil \\notin Server",
            "(Leader # Follower) /\\ (Leader # Candidate)",
            "(Follower # Candidate)",
            "Server = Server",
            "Quorum \\subseteq Server",
            "MaxLogLen \\in Nat",
            "MaxTerm \\in Nat"
        ],
        "lemma_def_expands": {
            "H_RequestVoteQuorumInTermImpliesNoOtherLogsInTerm": ["ExistsRequestVoteResponseQuorum"]
        },
        "action_def_expands":{
            "HandleRequestVoteRequestAction": ["LastTerm","RequestVoteRequestType","RequestVoteResponseType","Terms","LogIndicesWithZero"],
            "HandleRequestVoteResponseAction": ["LastTerm","RequestVoteRequestType","RequestVoteResponseType","Terms","LogIndicesWithZero"]
        }
    }
}